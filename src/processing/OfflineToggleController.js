/**
 * @file OfflineToggleController.js
 * @module processing/OfflineToggleController
 * @description Generates JavaScript controller for offline toggle interactivity.
 * 
 * This module generates a self-contained JavaScript snippet that:
 * - Initializes toggle elements with their dual-state content
 * - Handles click events to toggle between collapsed/expanded states
 * - Animates the toggle icon (rotation)
 * - Updates ARIA attributes for accessibility
 * - Works entirely offline without any external dependencies
 * 
 * The generated script is injected into saved HTML pages by ToggleCaptureStep.
 * 
 * @see {@link ./ToggleStateCapture.js}
 * @see {@link ../Docs/29112025_Codebase_Review.md} Section 5.6
 */

'use strict';

/**
 * @class OfflineToggleController
 * @classdesc Static generator for offline toggle interactivity scripts.
 * 
 * This class doesn't maintain instance state - all methods are static.
 * It generates JavaScript code that will run in the offline HTML context.
 */
class OfflineToggleController {
    /**
     * Generate the complete toggle controller script.
     * @static
     * @param {Map<string, ToggleState>|Object} toggleStates - Toggle state map or plain object
     * @returns {string} JavaScript code to inject
     */
    static generateScript(toggleStates) {
        // Convert Map to plain object if necessary
        const statesObj = toggleStates instanceof Map 
            ? Object.fromEntries(toggleStates)
            : toggleStates;

        // Serialize state data for embedding
        const serializedStates = JSON.stringify(statesObj, null, 2);

        // Generate the self-contained controller script
        return `
/**
 * Notion Offline Toggle Controller
 * Generated by notion-scraper at ${new Date().toISOString()}
 * 
 * This script enables offline interactivity for Notion toggle elements.
 * It manages the dual-state (collapsed/expanded) content captured during scraping.
 */
(function() {
    'use strict';

    // Toggle state data (captured during scraping)
    const TOGGLE_STATES = ${serializedStates};

    // Track initialization state
    let initialized = false;

    /**
     * Initialize all toggles when DOM is ready.
     */
    function init() {
        if (initialized) return;
        initialized = true;

        const toggleIds = Object.keys(TOGGLE_STATES);
        console.log('[OfflineToggle] Initializing ' + toggleIds.length + ' toggle(s)');

        toggleIds.forEach(function(toggleId) {
            try {
                initializeToggle(toggleId);
            } catch (error) {
                console.warn('[OfflineToggle] Failed to initialize toggle ' + toggleId + ':', error);
            }
        });

        console.log('[OfflineToggle] Initialization complete');
    }

    /**
     * Initialize a single toggle element.
     * @param {string} toggleId - The toggle block ID
     */
    function initializeToggle(toggleId) {
        const state = TOGGLE_STATES[toggleId];
        if (!state) return;

        // Find the trigger element
        const trigger = document.querySelector(state.triggerSelector);
        if (!trigger) {
            // Try alternative selector based on data-block-id
            const block = document.querySelector('[data-block-id="' + toggleId + '"]');
            if (!block) {
                console.warn('[OfflineToggle] Toggle not found: ' + toggleId);
                return;
            }
            // Find button within block
            var altTrigger = block.querySelector('[role="button"][aria-expanded]');
            if (!altTrigger) return;
            setupToggle(toggleId, altTrigger, state);
        } else {
            setupToggle(toggleId, trigger, state);
        }
    }

    /**
     * Set up event handlers and initial state for a toggle.
     * @param {string} toggleId - Toggle ID
     * @param {Element} trigger - Trigger button element
     * @param {Object} state - Toggle state data
     */
    function setupToggle(toggleId, trigger, state) {
        // Prevent double initialization
        if (trigger.dataset.offlineToggleInitialized) return;
        trigger.dataset.offlineToggleInitialized = 'true';

        // Get or create content container
        const block = trigger.closest('[data-block-id]') || trigger.parentElement;
        let contentContainer = block.querySelector('.offline-toggle-content');
        
        if (!contentContainer) {
            contentContainer = createContentContainer(block, trigger);
        }

        // Store references for event handler
        trigger._toggleState = {
            toggleId: toggleId,
            state: state,
            contentContainer: contentContainer
        };

        // Set initial content (collapsed by default)
        const isExpanded = trigger.getAttribute('aria-expanded') === 'true';
        setToggleContent(trigger, isExpanded);

        // Add click handler
        trigger.addEventListener('click', handleToggleClick);

        // Add keyboard support
        trigger.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                handleToggleClick.call(trigger, e);
            }
        });
    }

    /**
     * Create a content container for the toggle.
     * @param {Element} block - Parent block element
     * @param {Element} trigger - Trigger button element
     * @returns {Element} Content container element
     */
    function createContentContainer(block, trigger) {
        const container = document.createElement('div');
        container.className = 'offline-toggle-content';
        
        // Insert after the trigger's row/wrapper
        const triggerParent = trigger.parentElement;
        if (triggerParent && triggerParent !== block) {
            // Insert after the trigger's immediate parent
            if (triggerParent.nextSibling) {
                block.insertBefore(container, triggerParent.nextSibling);
            } else {
                block.appendChild(container);
            }
        } else {
            block.appendChild(container);
        }

        return container;
    }

    /**
     * Handle toggle click event.
     * @param {Event} e - Click event
     */
    function handleToggleClick(e) {
        e.preventDefault();
        e.stopPropagation();

        var trigger = this;
        var data = trigger._toggleState;
        if (!data) return;

        var isExpanded = trigger.getAttribute('aria-expanded') === 'true';
        var newState = !isExpanded;

        // Update ARIA state
        trigger.setAttribute('aria-expanded', newState.toString());

        // Update aria-label for accessibility
        trigger.setAttribute('aria-label', newState ? 'Close' : 'Open');

        // Animate icon
        animateToggleIcon(trigger, newState);

        // Update content
        setToggleContent(trigger, newState);
    }

    /**
     * Update the content display based on toggle state.
     * @param {Element} trigger - Trigger element
     * @param {boolean} expanded - Whether toggle should be expanded
     */
    function setToggleContent(trigger, expanded) {
        var data = trigger._toggleState;
        if (!data || !data.contentContainer) return;

        var container = data.contentContainer;
        var state = data.state;

        // Set content HTML
        container.innerHTML = expanded ? state.expandedHtml : state.collapsedHtml;
        
        // Toggle visibility
        container.style.display = expanded ? 'block' : 'none';
        
        // Add transition class for smooth animation
        container.classList.toggle('expanded', expanded);
    }

    /**
     * Animate the toggle icon rotation.
     * @param {Element} trigger - Trigger element
     * @param {boolean} expanded - Whether toggle is now expanded
     */
    function animateToggleIcon(trigger, expanded) {
        var icon = trigger.querySelector('svg');
        if (icon) {
            // Notion uses rotateZ(-90deg) for collapsed, rotateZ(0deg) for expanded
            icon.style.transform = expanded ? 'rotateZ(0deg)' : 'rotateZ(-90deg)';
        }
    }

    // Initialize on DOM ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
    } else {
        init();
    }

    // Also run on window load as backup
    window.addEventListener('load', init);

    // Expose for debugging
    window.__notionOfflineToggle = {
        states: TOGGLE_STATES,
        reinit: init
    };
})();
`;
    }

    /**
     * Generate CSS styles for offline toggle elements.
     * @static
     * @returns {string} CSS rules to inject
     */
    static generateStyles() {
        return `
/* Notion Offline Toggle Styles */
.offline-toggle-content {
    overflow: hidden;
    transition: max-height 0.2s ease-out, opacity 0.2s ease-out;
}

.offline-toggle-content.expanded {
    max-height: none;
}

/* Ensure toggle buttons are clickable */
[role="button"][aria-expanded] {
    cursor: pointer;
}

/* SVG icon transition for smooth rotation */
[role="button"][aria-expanded] svg {
    transition: transform 0.2s ease-out;
}

/* Focus styles for accessibility */
[role="button"][aria-expanded]:focus {
    outline: 2px solid rgba(55, 53, 47, 0.3);
    outline-offset: 2px;
}

/* Hover effect */
[role="button"][aria-expanded]:hover {
    background-color: rgba(55, 53, 47, 0.08);
}
`;
    }

    /**
     * Generate a minified version of the script.
     * @static
     * @param {Map<string, ToggleState>|Object} toggleStates - Toggle states
     * @returns {string} Minified JavaScript
     */
    static generateMinifiedScript(toggleStates) {
        const script = OfflineToggleController.generateScript(toggleStates);
        // Basic minification: remove comments and extra whitespace
        return script
            .replace(/\/\*[\s\S]*?\*\//g, '')  // Remove block comments
            .replace(/\/\/.*$/gm, '')          // Remove line comments
            .replace(/\s+/g, ' ')              // Collapse whitespace
            .replace(/\s*([{}();,:])\s*/g, '$1')  // Remove space around punctuation
            .trim();
    }
}

module.exports = OfflineToggleController;
